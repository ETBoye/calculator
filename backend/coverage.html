
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/etboye/calculator/api/compute.go (0.0%)</option>
				
				<option value="file1">github.com/etboye/calculator/calculation/expressioncalculator.go (100.0%)</option>
				
				<option value="file2">github.com/etboye/calculator/calculation/expressionmodel.go (8.7%)</option>
				
				<option value="file3">github.com/etboye/calculator/calculation/expressionmodeleval.go (100.0%)</option>
				
				<option value="file4">github.com/etboye/calculator/calculation/expressionparser.go (100.0%)</option>
				
				<option value="file5">github.com/etboye/calculator/main.go (0.0%)</option>
				
				<option value="file6">github.com/etboye/calculator/server/ginserver.go (0.0%)</option>
				
				<option value="file7">github.com/etboye/calculator/util/panicrecover.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/etboye/calculator/calculation"
)

type ComputeRequest struct {
        Input string `json:"input"`
}

type ComputeResponse struct {
        CalculationResult *calculation.CalculationResult `json:"calculationResult"`
        Error             *string                        `json:"error"`
}

type ComputationHandler interface {
        GetResponse(computeRequest ComputeRequest) SimpleHttpResponse[ComputeResponse]
}

var EMPTY_INPUT_ERROR string = "Input was empty"

type StandardComputationHandler struct {
        calculator calculation.Calculator
}

func NewStandardComputationHandler(calculator calculation.Calculator) StandardComputationHandler <span class="cov0" title="0">{
        return StandardComputationHandler{
                calculator: calculator,
        }
}</span>

func (c StandardComputationHandler) GetResponse(computeRequest ComputeRequest) SimpleHttpResponse[ComputeResponse] <span class="cov0" title="0">{
        input := computeRequest.Input
        if len(strings.TrimSpace(input)) == 0 </span><span class="cov0" title="0">{
                return SimpleHttpResponse[ComputeResponse]{ // TODO: Test
                        Status:   http.StatusBadRequest,
                        Response: ComputeResponse{Error: &amp;EMPTY_INPUT_ERROR},
                }
        }</span>

        <span class="cov0" title="0">calculationResult := c.calculator.Compute(calculation.CalculationInput{Input: input})

        return SimpleHttpResponse[ComputeResponse]{
                Status: http.StatusOK,
                Response: ComputeResponse{
                        CalculationResult: &amp;calculationResult,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package calculation

import (
        "errors"
        "log"

        "github.com/etboye/calculator/util"
)

type Parser interface {
        Parse(calculationInput CalculationInput) (*Expression, error)
}

type ExpressionCalculator struct {
        parser Parser
}

func NewExpressionCalculatorWithParser(parser Parser) ExpressionCalculator <span class="cov8" title="1">{
        return ExpressionCalculator{parser: parser}
}</span>

func NewDefaultExpressionCalculator() ExpressionCalculator <span class="cov8" title="1">{
        parser := newParticipleParser()
        return ExpressionCalculator{parser: &amp;parser}
}</span>

func (calculator ExpressionCalculator) Compute(input CalculationInput) CalculationResult <span class="cov8" title="1">{
        // I think I've seen the parser panic sometimes on really bad inputs
        // I can't seem to reproduce this - but we protect for it anyways
        expression, err := util.RecoverFromPanicWithError(
                func() (*Expression, error) </span><span class="cov8" title="1">{ return calculator.parser.Parse(input) }</span>,
                nil, errors.New(PARSING_ERROR_ID), "Recovered from parsing panic")

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                errorId := err.Error()
                return CalculationResult{ErrorId: &amp;errorId}
        }</span>

        <span class="cov8" title="1">resultAsRat, err := expression.Eval()

        if err != nil </span><span class="cov8" title="1">{
                errorId := err.Error()
                log.Println("Calculation returned error with id", errorId)
                return CalculationResult{
                        ErrorId: &amp;errorId,
                }
        }</span>

        <span class="cov8" title="1">result := RationalNumber{
                Num:      resultAsRat.Num().String(),
                Denom:    resultAsRat.Denom().String(),
                Estimate: resultAsRat.FloatString(PRECISION_DIGITS),
        }

        return CalculationResult{Result: &amp;result}</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package calculation

import (
        "fmt"
        "strings"
)

// Borrowing heavily from https://github.com/alecthomas/participle/blob/master/_examples/expr/main.go
type Operator int

const (
        OpMul Operator = iota
        OpQuo
        OpAdd
        OpSub
)

var operatorMap = map[string]Operator{"+": OpAdd, "-": OpSub, "*": OpMul, "/": OpQuo}

func (o *Operator) Capture(s []string) error <span class="cov8" title="1">{
        *o = operatorMap[s[0]]
        return nil
}</span>

type Value struct {
        IntegerWithoutSign *string     `@UnsignedInteger`
        IntegerWithSign    *string     `| OpSub@UnsignedInteger`
        Subexpression      *Expression `| StartParen@@EndParen`
}

type OpFactor struct {
        Operator Operator `@(OpMul|OpQuo)`
        Factor   *Value   `@@`
}

type Term struct {
        Left  *Value      `@@`
        Right []*OpFactor `@@*`
}

type OpTerm struct {
        Operator Operator `@(OpAdd|OpSub)`
        Term     *Term    `@@`
}

type Expression struct {
        Left  *Term     `@@`
        Right []*OpTerm `@@*`
}

// Display

func (o Operator) String() string <span class="cov0" title="0">{
        switch o </span>{
        case OpMul:<span class="cov0" title="0">
                return "*"</span>
        case OpQuo:<span class="cov0" title="0">
                return "/"</span>
        case OpSub:<span class="cov0" title="0">
                return "-"</span>
        case OpAdd:<span class="cov0" title="0">
                return "+"</span>
        }
        <span class="cov0" title="0">panic("unsupported operator")</span>
}

func (v *Value) String() string <span class="cov0" title="0">{
        if v.IntegerWithoutSign != nil </span><span class="cov0" title="0">{
                return *v.IntegerWithoutSign
        }</span> else<span class="cov0" title="0"> if v.IntegerWithSign != nil </span><span class="cov0" title="0">{
                return "-" + *v.IntegerWithSign
        }</span>
        <span class="cov0" title="0">return "(" + v.Subexpression.String() + ")"</span>
}

func (o *OpFactor) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", o.Operator, o.Factor)
}</span>

func (t *Term) String() string <span class="cov0" title="0">{
        out := []string{t.Left.String()}
        for _, r := range t.Right </span><span class="cov0" title="0">{
                out = append(out, r.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(out, " ")</span>
}

func (o *OpTerm) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", o.Operator, o.Term)
}</span>

func (e *Expression) String() string <span class="cov0" title="0">{
        out := []string{e.Left.String()}
        for _, r := range e.Right </span><span class="cov0" title="0">{
                out = append(out, r.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(out, " ")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package calculation

import (
        "errors"
        "math/big"
        "strings"
)

// precondition: digitStringWithSign matches `-\d+`
func ratFromIntegerString(digitStringWithSign string) *big.Rat <span class="cov8" title="1">{
        rat := big.NewRat(1, 1)

        bigInt := big.NewInt(1)
        bigInt.SetString(digitStringWithSign, 10)
        rat.SetInt(bigInt)

        return rat
}</span>

func (t *Term) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        result, err := t.Left.Eval()

        if err != nil </span><span class="cov8" title="1">{
                return result, err
        }</span>

        <span class="cov8" title="1">if t.Right == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        <span class="cov8" title="1">for _, opTerm := range t.Right </span><span class="cov8" title="1">{
                factorEval, err := opTerm.Factor.Eval()

                if err != nil </span><span class="cov8" title="1">{
                        return big.NewRat(1, 1), err
                }</span>

                <span class="cov8" title="1">if opTerm.Operator == OpMul </span><span class="cov8" title="1">{
                        result.Mul(result, factorEval)
                }</span> else<span class="cov8" title="1"> {
                        if factorEval.Cmp(big.NewRat(0, 1)) == 0 </span><span class="cov8" title="1">{
                                return big.NewRat(1, 1), errors.New(DIVISION_BY_ZERO_ERROR_ID)
                        }</span>

                        <span class="cov8" title="1">result.Quo(result, factorEval)</span> // TODO: Zero division and test for the same
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (e *Expression) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        result, err := e.Left.Eval()

        if err != nil </span><span class="cov8" title="1">{
                return result, err
        }</span>

        <span class="cov8" title="1">if e.Right == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        <span class="cov8" title="1">for _, opTerm := range e.Right </span><span class="cov8" title="1">{
                termEval, err := opTerm.Term.Eval()

                if err != nil </span><span class="cov8" title="1">{
                        return big.NewRat(1, 1), err
                }</span>

                <span class="cov8" title="1">if opTerm.Operator == OpAdd </span><span class="cov8" title="1">{
                        result.Add(result, termEval)
                }</span> else<span class="cov8" title="1"> {
                        result.Sub(result, termEval)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (v *Value) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        if v.IntegerWithSign != nil </span><span class="cov8" title="1">{
                return ratFromIntegerString("-" + strings.TrimSpace(*v.IntegerWithSign)), nil
        }</span> else<span class="cov8" title="1"> if v.IntegerWithoutSign != nil </span><span class="cov8" title="1">{
                return ratFromIntegerString(strings.TrimSpace(*v.IntegerWithoutSign)), nil
        }</span>

        <span class="cov8" title="1">return v.Subexpression.Eval()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package calculation

import (
        "errors"
        "fmt"
        "log"
        "strings"

        "github.com/alecthomas/participle/v2"
        "github.com/alecthomas/participle/v2/lexer"
)

type participleParser struct {
        parser        *participle.Parser[Expression]
        lexingSymbols map[lexer.TokenType]string
}

func (parser *participleParser) Parse(input CalculationInput) (*Expression, error) <span class="cov8" title="1">{
        if len(strings.TrimSpace(input.Input)) == 0 </span><span class="cov8" title="1">{
                log.Printf("Received empty input")
                return nil, errors.New(EMPTY_INPUT_ERROR_ID)
        }</span>

        <span class="cov8" title="1">tokens, lexerError := parser.parser.Lex("", strings.NewReader(input.Input))

        if lexerError != nil </span><span class="cov8" title="1">{
                log.Println("Lexing error thrown:", lexerError.Error())
                return nil, errors.New(LEXING_ERROR_ID)

        }</span>

        <span class="cov8" title="1">logLexingResult(input, tokens, parser.lexingSymbols)

        expression, err := parser.parser.ParseString("", input.Input) // This actually lexes again. We accept this..

        if err != nil </span><span class="cov8" title="1">{
                log.Println("Parsing error thrown:", err.Error())
                return nil, errors.New(PARSING_ERROR_ID)
        }</span>

        <span class="cov8" title="1">log.Printf("Parsing succesful. Has parsed to %s", expression)
        return expression, nil</span>
}

func newParticipleParser() participleParser <span class="cov8" title="1">{
        var myLexer = lexer.MustSimple([]lexer.SimpleRule{
                {Name: "UnsignedInteger", Pattern: `\d+`},
                {Name: "OpAdd", Pattern: `\+`},
                {Name: "OpSub", Pattern: `-`},
                {Name: "OpMul", Pattern: `\*`},
                {Name: "OpQuo", Pattern: `/`},
                {Name: "StartParen", Pattern: `\(`},
                {Name: "EndParen", Pattern: `\)`},
                {Name: "WhiteSpace", Pattern: `[\s]*`},
        })

        parser := participle.MustBuild[Expression](
                participle.Lexer(myLexer),
                participle.Elide("WhiteSpace"), // The parser should ignore any whitespace

        )

        return participleParser{parser: parser, lexingSymbols: lexer.SymbolsByRune(myLexer)}
}</span>

func logLexingResult(input CalculationInput, tokens []lexer.Token, lexingSymbols map[lexer.TokenType]string) <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Lexed input \"%s\". Tokens: ", input.Input))

        for _, token := range tokens </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%s(%s)", lexingSymbols[token.Type], token.Value))
        }</span>

        <span class="cov8" title="1">log.Println(sb.String())</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/etboye/calculator/api"
        "github.com/etboye/calculator/calculation"
        "github.com/etboye/calculator/server"
)

type Application struct {
        calculator calculation.Calculator
}

func main() <span class="cov0" title="0">{
        server := server.GinServer{}

        calculator := calculation.NewDefaultExpressionCalculator()

        endpoints := api.Endpoints{
                ComputationHandler: api.NewStandardComputationHandler(&amp;calculator),
        }
        server.StartServer(endpoints)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package server

import (
        "bytes"
        "io"
        "log"
        "log/slog"
        "net/http"
        "os"

        sloggin "github.com/samber/slog-gin"

        "github.com/etboye/calculator/api"
        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
)

type GinServer struct {
}

func (ginServer *GinServer) StartServer(endpoints api.Endpoints) error <span class="cov0" title="0">{
        router := gin.Default()

        setupLogging(router)
        registerEndpoints(router, endpoints)

        return router.Run()
}</span>

func setupLogging(router *gin.Engine) <span class="cov0" title="0">{
        config := sloggin.Config{
                WithRequestBody:    true,
                WithRequestHeader:  true,
                WithResponseBody:   true,
                WithResponseHeader: true,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, nil))

        router.Use(sloggin.NewWithConfig(logger, config))
}</span>

func registerEndpoints(router *gin.Engine, endpoints api.Endpoints) <span class="cov0" title="0">{
        router.POST("/compute", func(c *gin.Context) </span><span class="cov0" title="0">{
                computeRequest := api.ComputeRequest{}

                if unmarshallError := c.ShouldBindBodyWith(&amp;computeRequest, binding.JSON); unmarshallError != nil </span><span class="cov0" title="0">{
                        bodyAsString := getBodyAsString(c.Request.Body)
                        log.Println("Could not marshall request", bodyAsString) // TODO: Test this
                        c.Status(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">computeResponse := endpoints.ComputationHandler.GetResponse(computeRequest)
                sendSimpleHttpResponse(c, computeResponse)</span>
        })
}

func getBodyAsString(body io.ReadCloser) string <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        buf.ReadFrom(body)
        return buf.String()
}</span>

func sendSimpleHttpResponse[T any](c *gin.Context, httpResponse api.SimpleHttpResponse[T]) <span class="cov0" title="0">{
        c.JSON(httpResponse.Status, httpResponse.Response)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package util

import "fmt"

type withError[T any] struct {
        t   T
        err error
}

func RecoverFromPanicWithError[T any](f func() (T, error), recoverItem T, recoverError error, recoverMessage string) (T, error) <span class="cov8" title="1">{

        resultWithError := RecoverFromPanic[withError[T]](func() withError[T] </span><span class="cov8" title="1">{
                t, err := f()

                result := withError[T]{t: t, err: err}
                return result
        }</span>, withError[T]{t: recoverItem, err: recoverError}, recoverMessage)

        <span class="cov8" title="1">return resultWithError.t, resultWithError.err</span>
}

func RecoverFromPanic[T any](f func() T, recoverItem T, recoverMessage string) T <span class="cov8" title="1">{
        c := make(chan T)

        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                fmt.Println(recoverMessage, r)
                                c &lt;- recoverItem
                        }</span>
                }()

                <span class="cov8" title="1">c &lt;- f()</span>
        }()

        <span class="cov8" title="1">result := &lt;-c
        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
