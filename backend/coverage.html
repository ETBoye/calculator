
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/etboye/calculator/api/compute.go (0.0%)</option>
				
				<option value="file1">github.com/etboye/calculator/api/history.go (0.0%)</option>
				
				<option value="file2">github.com/etboye/calculator/api/validation.go (0.0%)</option>
				
				<option value="file3">github.com/etboye/calculator/calculation/expressioncalculator.go (100.0%)</option>
				
				<option value="file4">github.com/etboye/calculator/calculation/expressionmodel.go (8.7%)</option>
				
				<option value="file5">github.com/etboye/calculator/calculation/expressionmodeleval.go (100.0%)</option>
				
				<option value="file6">github.com/etboye/calculator/calculation/expressionparser.go (100.0%)</option>
				
				<option value="file7">github.com/etboye/calculator/main.go (0.0%)</option>
				
				<option value="file8">github.com/etboye/calculator/persistence/client.go (0.0%)</option>
				
				<option value="file9">github.com/etboye/calculator/server/ginserver.go (0.0%)</option>
				
				<option value="file10">github.com/etboye/calculator/util/panicrecover.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "strings"

        "github.com/etboye/calculator/calculation"
        "github.com/etboye/calculator/persistence"
)

type ComputeRequest struct {
        Input string `json:"input"`
}

type ComputeResponse struct {
        HistoryRow *persistence.HistoryRow `json:"historyRow"`
        Error      *string                 `json:"error"`
}

type ComputationHandler interface {
        Compute(sessionId string, computeRequest ComputeRequest) SimpleHttpResponse[ComputeResponse]
}

var EMPTY_INPUT_ERROR string = "Input was empty"

type StandardComputationHandler struct {
        calculator        calculation.Calculator
        persistenceClient persistence.PersistenceClient
}

func NewStandardComputationHandler(calculator calculation.Calculator,
        persistenceClient persistence.PersistenceClient) StandardComputationHandler <span class="cov0" title="0">{

        return StandardComputationHandler{
                calculator:        calculator,
                persistenceClient: persistenceClient,
        }
}</span>

func (c StandardComputationHandler) Compute(sessionId string, computeRequest ComputeRequest) SimpleHttpResponse[ComputeResponse] <span class="cov0" title="0">{

        sessionIdValidationErr := validateSessionId(sessionId)
        if sessionIdValidationErr != nil </span><span class="cov0" title="0">{
                errorId := sessionIdValidationErr.Error()
                return SimpleHttpResponse[ComputeResponse]{ // TODO: Test
                        Status:   http.StatusBadRequest,
                        Response: ComputeResponse{Error: &amp;errorId},
                }
        }</span>

        <span class="cov0" title="0">input := computeRequest.Input
        if len(strings.TrimSpace(input)) == 0 </span><span class="cov0" title="0">{
                return SimpleHttpResponse[ComputeResponse]{ // TODO: Test
                        Status:   http.StatusBadRequest,
                        Response: ComputeResponse{Error: &amp;EMPTY_INPUT_ERROR},
                }
        }</span>

        <span class="cov0" title="0">calculationResult := c.calculator.Compute(input)

        historyRow, persistenceError := c.persistenceClient.SaveComputation(sessionId, input, calculationResult)

        if persistenceError != nil </span><span class="cov0" title="0">{
                errorId := persistenceError.Error()
                return SimpleHttpResponse[ComputeResponse]{ // TODO: Test
                        Status:   http.StatusInternalServerError,
                        Response: ComputeResponse{Error: &amp;errorId},
                }
        }</span>

        <span class="cov0" title="0">return SimpleHttpResponse[ComputeResponse]{
                Status: http.StatusCreated,
                Response: ComputeResponse{
                        HistoryRow: &amp;historyRow,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"
        "log"
        "net/http"
        "strconv"

        "github.com/etboye/calculator/persistence"
)

// We copy the pattern from https://opensource.zalando.com/restful-api-guidelines/#pagination
type CalculationsPage struct { // Page as in pagination object, not web page
        Self  *string                  `json:"self"`
        First *string                  `json:"first"`
        Prev  *string                  `json:"prev"`
        Next  *string                  `json:"next"`
        Last  *string                  `json:"last"`
        Items []persistence.HistoryRow `json:"items"`
        Error *string                  `json:"error"`
}

type SessionHistoryHandler interface {
        GetSessionHistory(sessionId string, cursorQuery string) SimpleHttpResponse[CalculationsPage]
}

type StandardSessionHistoryHandler struct {
        persistenceClient persistence.PersistenceClient
}

func NewStandardSessionHistoryHandler(persistenceClient persistence.PersistenceClient) StandardSessionHistoryHandler <span class="cov0" title="0">{
        return StandardSessionHistoryHandler{persistenceClient: persistenceClient}
}</span>

func (historyHandler StandardSessionHistoryHandler) GetSessionHistory(sessionId string, cursorQuery string) SimpleHttpResponse[CalculationsPage] <span class="cov0" title="0">{
        sessionIdValidationErr := validateSessionId(sessionId)

        if sessionIdValidationErr != nil </span><span class="cov0" title="0">{
                errorId := sessionIdValidationErr.Error()
                return SimpleHttpResponse[CalculationsPage]{ // TODO: Test
                        Status:   http.StatusBadRequest,
                        Response: CalculationsPage{Error: &amp;errorId},
                }
        }</span>

        <span class="cov0" title="0">var unmappedCalculationsPage persistence.CalculationsPageObject
        var persistenceError error

        if cursorQuery == "" </span><span class="cov0" title="0">{
                unmappedCalculationsPage, persistenceError = historyHandler.persistenceClient.GetSessionHistoryFirstPage(sessionId)
        }</span> else<span class="cov0" title="0"> {
                cursor, cursorParseErr := strconv.ParseInt(cursorQuery, 10, 64)

                if cursorParseErr != nil </span><span class="cov0" title="0">{
                        errorId := "CURSOR_PARSING_ERROR"
                        log.Printf("Could not parse %s as int", cursorQuery)
                        return SimpleHttpResponse[CalculationsPage]{ // TODO: Test
                                Status:   http.StatusBadRequest,
                                Response: CalculationsPage{Error: &amp;errorId},
                        }
                }</span>
                <span class="cov0" title="0">unmappedCalculationsPage, persistenceError = historyHandler.persistenceClient.GetSessionHistory(sessionId, cursor)</span>
        }

        <span class="cov0" title="0">if persistenceError != nil </span><span class="cov0" title="0">{
                errorId := persistenceError.Error()
                return SimpleHttpResponse[CalculationsPage]{ // TODO: Test
                        Status:   http.StatusInternalServerError,
                        Response: CalculationsPage{Error: &amp;errorId},
                }
        }</span>

        <span class="cov0" title="0">return SimpleHttpResponse[CalculationsPage]{
                Status:   http.StatusOK,
                Response: mapPage(sessionId, unmappedCalculationsPage),
        }</span>
}

func mapPage(sessionId string, unmappedCalculationsPage persistence.CalculationsPageObject) CalculationsPage <span class="cov0" title="0">{
        return CalculationsPage{
                Self:  getEndpointUrl(sessionId, unmappedCalculationsPage.Self),
                First: getEndpointUrl(sessionId, unmappedCalculationsPage.First),
                Prev:  getEndpointUrl(sessionId, unmappedCalculationsPage.Prev),
                Next:  getEndpointUrl(sessionId, unmappedCalculationsPage.Next),
                Last:  getEndpointUrl(sessionId, unmappedCalculationsPage.Last),
                Items: unmappedCalculationsPage.Items,
        }
}</span>

func getEndpointUrl(sessionId string, cursor *int64) *string <span class="cov0" title="0">{
        if cursor == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := fmt.Sprintf("/sessions/%s/history?cursor=%d", sessionId, *cursor)
        return &amp;result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
        "log"
        "regexp"
)

var sessionIdPatternString string = `^[a-zA-Z0-9\-]*$`
var sessionIdPattern *regexp.Regexp = regexp.MustCompile(sessionIdPatternString)
var sessionIdMinLength int = 1
var sessionIdMaxLength int = 100
var sessionIdValidationErrorId = "SESSION_ID_VALIDATION_ERROR"

func validateSessionId(sessionId string) error <span class="cov0" title="0">{
        log.Println("Got sessionId: ", sessionId)

        if !sessionIdPattern.MatchString(sessionId) </span><span class="cov0" title="0">{
                log.Printf("sessionId must match pattern %s", sessionIdPatternString)
                return errors.New(sessionIdValidationErrorId)
        }</span>

        <span class="cov0" title="0">if len(sessionId) &gt; sessionIdMaxLength </span><span class="cov0" title="0">{
                log.Printf("sessionId must have length at most %d", sessionIdMaxLength) // TODO: test
                return errors.New(sessionIdValidationErrorId)
        }</span>

        <span class="cov0" title="0">if len(sessionId) &lt; sessionIdMinLength </span><span class="cov0" title="0">{
                log.Printf("sessionId must have length at minimum %d", sessionIdMinLength) // TODO: test
                return errors.New(sessionIdValidationErrorId)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package calculation

import (
        "errors"
        "log"

        "github.com/etboye/calculator/util"
)

type Parser interface {
        Parse(input string) (*Expression, error)
}

type ExpressionCalculator struct {
        parser Parser
}

func NewExpressionCalculatorWithParser(parser Parser) ExpressionCalculator <span class="cov8" title="1">{
        return ExpressionCalculator{parser: parser}
}</span>

func NewDefaultExpressionCalculator() ExpressionCalculator <span class="cov8" title="1">{
        parser := newParticipleParser()
        return ExpressionCalculator{parser: &amp;parser}
}</span>

func (calculator ExpressionCalculator) Compute(input string) CalculationResult <span class="cov8" title="1">{
        // I think I've seen the parser panic sometimes on really bad inputs
        // I can't seem to reproduce this - but we try to protect against it anyways
        expression, err := util.RecoverFromPanicWithError(
                func() (*Expression, error) </span><span class="cov8" title="1">{ return calculator.parser.Parse(input) }</span>,
                nil, errors.New(PARSING_OR_LEXING_PANIC_ERROR_ID), "Recovered from parsing panic")

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                errorId := err.Error()
                return CalculationResult{Input: &amp;input, ErrorId: &amp;errorId}
        }</span>

        <span class="cov8" title="1">resultAsRat, err := expression.Eval()

        if err != nil </span><span class="cov8" title="1">{
                errorId := err.Error()
                log.Println("Calculation returned error with id", errorId)
                return CalculationResult{
                        Input:   &amp;input,
                        ErrorId: &amp;errorId,
                }
        }</span>

        <span class="cov8" title="1">result := RationalNumber{
                Num:      resultAsRat.Num().String(),
                Denom:    resultAsRat.Denom().String(),
                Estimate: resultAsRat.FloatString(PRECISION_DIGITS),
        }

        return CalculationResult{Input: &amp;input, Result: &amp;result}</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package calculation

import (
        "fmt"
        "strings"
)

// Borrowing heavily from https://github.com/alecthomas/participle/blob/master/_examples/expr/main.go
type Operator int

const (
        OpMul Operator = iota
        OpQuo
        OpAdd
        OpSub
)

var operatorMap = map[string]Operator{"+": OpAdd, "-": OpSub, "*": OpMul, "/": OpQuo}

func (o *Operator) Capture(s []string) error <span class="cov8" title="1">{
        *o = operatorMap[s[0]]
        return nil
}</span>

type Value struct {
        IntegerWithoutSign *string     `@UnsignedInteger`
        IntegerWithSign    *string     `| OpSub@UnsignedInteger`
        Subexpression      *Expression `| StartParen@@EndParen`
}

type OpFactor struct {
        Operator Operator `@(OpMul|OpQuo)`
        Factor   *Value   `@@`
}

type Term struct {
        Left  *Value      `@@`
        Right []*OpFactor `@@*`
}

type OpTerm struct {
        Operator Operator `@(OpAdd|OpSub)`
        Term     *Term    `@@`
}

type Expression struct {
        Left  *Term     `@@`
        Right []*OpTerm `@@*`
}

// Display

func (o Operator) String() string <span class="cov0" title="0">{
        switch o </span>{
        case OpMul:<span class="cov0" title="0">
                return "*"</span>
        case OpQuo:<span class="cov0" title="0">
                return "/"</span>
        case OpSub:<span class="cov0" title="0">
                return "-"</span>
        case OpAdd:<span class="cov0" title="0">
                return "+"</span>
        }
        <span class="cov0" title="0">panic("unsupported operator")</span>
}

func (v *Value) String() string <span class="cov0" title="0">{
        if v.IntegerWithoutSign != nil </span><span class="cov0" title="0">{
                return *v.IntegerWithoutSign
        }</span> else<span class="cov0" title="0"> if v.IntegerWithSign != nil </span><span class="cov0" title="0">{
                return "-" + *v.IntegerWithSign
        }</span>
        <span class="cov0" title="0">return "(" + v.Subexpression.String() + ")"</span>
}

func (o *OpFactor) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", o.Operator, o.Factor)
}</span>

func (t *Term) String() string <span class="cov0" title="0">{
        out := []string{t.Left.String()}
        for _, r := range t.Right </span><span class="cov0" title="0">{
                out = append(out, r.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(out, " ")</span>
}

func (o *OpTerm) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", o.Operator, o.Term)
}</span>

func (e *Expression) String() string <span class="cov0" title="0">{
        out := []string{e.Left.String()}
        for _, r := range e.Right </span><span class="cov0" title="0">{
                out = append(out, r.String())
        }</span>
        <span class="cov0" title="0">return strings.Join(out, " ")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package calculation

import (
        "errors"
        "math/big"
        "strings"
)

// precondition: digitStringWithSign matches `-\d+`
func ratFromIntegerString(digitStringWithSign string) *big.Rat <span class="cov8" title="1">{
        rat := big.NewRat(1, 1)

        bigInt := big.NewInt(1)
        bigInt.SetString(digitStringWithSign, 10)
        rat.SetInt(bigInt)

        return rat
}</span>

func (t *Term) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        result, err := t.Left.Eval()

        if err != nil </span><span class="cov8" title="1">{
                return result, err
        }</span>

        <span class="cov8" title="1">if t.Right == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        <span class="cov8" title="1">for _, opTerm := range t.Right </span><span class="cov8" title="1">{
                factorEval, err := opTerm.Factor.Eval()

                if err != nil </span><span class="cov8" title="1">{
                        return big.NewRat(1, 1), err
                }</span>

                <span class="cov8" title="1">if opTerm.Operator == OpMul </span><span class="cov8" title="1">{
                        result.Mul(result, factorEval)
                }</span> else<span class="cov8" title="1"> {
                        if factorEval.Cmp(big.NewRat(0, 1)) == 0 </span><span class="cov8" title="1">{
                                return big.NewRat(1, 1), errors.New(DIVISION_BY_ZERO_ERROR_ID)
                        }</span>

                        <span class="cov8" title="1">result.Quo(result, factorEval)</span> // TODO: Zero division and test for the same
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (e *Expression) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        result, err := e.Left.Eval()

        if err != nil </span><span class="cov8" title="1">{
                return result, err
        }</span>

        <span class="cov8" title="1">if e.Right == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        <span class="cov8" title="1">for _, opTerm := range e.Right </span><span class="cov8" title="1">{
                termEval, err := opTerm.Term.Eval()

                if err != nil </span><span class="cov8" title="1">{
                        return big.NewRat(1, 1), err
                }</span>

                <span class="cov8" title="1">if opTerm.Operator == OpAdd </span><span class="cov8" title="1">{
                        result.Add(result, termEval)
                }</span> else<span class="cov8" title="1"> {
                        result.Sub(result, termEval)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (v *Value) Eval() (*big.Rat, error) <span class="cov8" title="1">{
        if v.IntegerWithSign != nil </span><span class="cov8" title="1">{
                return ratFromIntegerString("-" + strings.TrimSpace(*v.IntegerWithSign)), nil
        }</span> else<span class="cov8" title="1"> if v.IntegerWithoutSign != nil </span><span class="cov8" title="1">{
                return ratFromIntegerString(strings.TrimSpace(*v.IntegerWithoutSign)), nil
        }</span>

        <span class="cov8" title="1">return v.Subexpression.Eval()</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package calculation

import (
        "errors"
        "fmt"
        "log"
        "strings"

        "github.com/alecthomas/participle/v2"
        "github.com/alecthomas/participle/v2/lexer"
)

type participleParser struct {
        parser        *participle.Parser[Expression]
        lexingSymbols map[lexer.TokenType]string
}

func (parser *participleParser) Parse(input string) (*Expression, error) <span class="cov8" title="1">{
        if len(strings.TrimSpace(input)) == 0 </span><span class="cov8" title="1">{
                log.Printf("Received empty input")
                return nil, errors.New(EMPTY_INPUT_ERROR_ID)
        }</span>

        <span class="cov8" title="1">tokens, lexerError := parser.parser.Lex("", strings.NewReader(input))

        if lexerError != nil </span><span class="cov8" title="1">{
                log.Println("Lexing error thrown:", lexerError.Error())
                return nil, errors.New(LEXING_ERROR_ID)

        }</span>

        <span class="cov8" title="1">logLexingResult(input, tokens, parser.lexingSymbols)

        expression, err := parser.parser.ParseString("", input) // This actually lexes again. We accept this..

        if err != nil </span><span class="cov8" title="1">{
                log.Println("Parsing error thrown:", err.Error())
                return nil, errors.New(PARSING_ERROR_ID)
        }</span>

        <span class="cov8" title="1">log.Printf("Parsing succesful. Has parsed to %s", expression)
        return expression, nil</span>
}

func newParticipleParser() participleParser <span class="cov8" title="1">{
        var myLexer = lexer.MustSimple([]lexer.SimpleRule{
                {Name: "UnsignedInteger", Pattern: `\d+`},
                {Name: "OpAdd", Pattern: `\+`},
                {Name: "OpSub", Pattern: `-`},
                {Name: "OpMul", Pattern: `\*`},
                {Name: "OpQuo", Pattern: `/`},
                {Name: "StartParen", Pattern: `\(`},
                {Name: "EndParen", Pattern: `\)`},
                {Name: "WhiteSpace", Pattern: `[\s]*`},
        })

        parser := participle.MustBuild[Expression](
                participle.Lexer(myLexer),
                participle.Elide("WhiteSpace"), // The parser should ignore any whitespace

        )

        return participleParser{parser: parser, lexingSymbols: lexer.SymbolsByRune(myLexer)}
}</span>

func logLexingResult(input string, tokens []lexer.Token, lexingSymbols map[lexer.TokenType]string) <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(fmt.Sprintf("Lexed input \"%s\". Tokens: ", input))

        for _, token := range tokens </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%s(%s)", lexingSymbols[token.Type], token.Value))
        }</span>

        <span class="cov8" title="1">log.Println(sb.String())</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "log"
        "os"

        "github.com/etboye/calculator/api"
        "github.com/etboye/calculator/calculation"
        "github.com/etboye/calculator/persistence"
        "github.com/etboye/calculator/server"
)

func main() <span class="cov0" title="0">{
        server := server.GinServer{}

        persistenceClient, err := persistence.InitPostgresClient()

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Received error initialising persistence client: %s", err.Error())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">calculator := calculation.NewDefaultExpressionCalculator()

        endpoints := api.Endpoints{
                ComputationHandler:    api.NewStandardComputationHandler(&amp;calculator, persistenceClient),
                SessionHistoryHandler: api.NewStandardSessionHistoryHandler(persistenceClient),
        }
        server.StartServer(endpoints)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package persistence

import (
        "context"
        "errors"
        "fmt"
        "log"
        "os"

        "github.com/etboye/calculator/calculation"
        "github.com/jackc/pgx/v5"
)

var pageMaxNumberOfItems = 5

var fetchHistoryErrorId = "HISTORY_FETCH"
var scanRowHistoryError = "HISTORY_SCAN_ROW"
var computeCursorPositionsError = "HISTORY_CURSOR"
var insertCalculationError = "INSERT_CALCULATION"

type HistoryRow struct {
        CalculationId int64                         `json:"calculationId"`
        Calculation   calculation.CalculationResult `json:"calculation"`
}

type CalculationsPageObject struct { // Page as in pagination object, not web page
        Self  *int64
        First *int64
        Prev  *int64
        Next  *int64
        Last  *int64
        Items []HistoryRow
}

type CursorPositions struct {
        Self  *int64
        First *int64
        Prev  *int64
        Next  *int64
        Last  *int64
}

type PersistenceClient interface {
        SaveComputation(sessionId string, input string, calculationResult calculation.CalculationResult) (HistoryRow, error)
        GetSessionHistory(sessionId string, cursor int64) (CalculationsPageObject, error)
        GetSessionHistoryFirstPage(sessionId string) (CalculationsPageObject, error)
}

type PostgresClient struct {
        conn *pgx.Conn
}

func (postgresClient PostgresClient) SaveComputation(
        sessionId string, input string, calculationResult calculation.CalculationResult) (HistoryRow, error) <span class="cov0" title="0">{

        var num, denom, estimate *string
        if calculationResult.Result != nil </span><span class="cov0" title="0">{
                num = &amp;calculationResult.Result.Num
                denom = &amp;calculationResult.Result.Denom
                estimate = &amp;calculationResult.Result.Estimate
        }</span>
        <span class="cov0" title="0">row := postgresClient.conn.QueryRow(context.Background(),
                `INSERT INTO history (sessionId, input, outputNum, outputDenom, outputEstimate, error) VALUES 
                ($1, $2, $3, $4, $5, $6) returning calculationId`,
                sessionId,
                input,
                num, denom, estimate,
                calculationResult.ErrorId,
        )

        var createdCalculationId int64
        err := row.Scan(&amp;createdCalculationId)

        if err != nil </span><span class="cov0" title="0">{
                return HistoryRow{}, errors.New(insertCalculationError)
        }</span>

        <span class="cov0" title="0">return HistoryRow{
                CalculationId: createdCalculationId,
                Calculation:   calculationResult,
        }, nil</span>
}

func scanHistoryRow(rows pgx.Rows) (HistoryRow, error) <span class="cov0" title="0">{
        var calculationId int64
        var input string
        var outputnum *string
        var outputdenom *string
        var outputestimate *string
        var error *string

        err := rows.Scan(&amp;calculationId, &amp;input, &amp;outputnum, &amp;outputdenom, &amp;outputestimate, &amp;error)

        if err != nil </span><span class="cov0" title="0">{
                return HistoryRow{}, err
        }</span>

        <span class="cov0" title="0">var rationalNumber *calculation.RationalNumber = nil

        if outputnum != nil &amp;&amp; outputdenom != nil &amp;&amp; outputestimate != nil </span><span class="cov0" title="0">{
                rat := calculation.RationalNumber{
                        Num:      *outputnum,
                        Denom:    *outputdenom,
                        Estimate: *outputestimate,
                }

                rationalNumber = &amp;rat
        }</span>

        <span class="cov0" title="0">return HistoryRow{
                CalculationId: calculationId,
                Calculation: calculation.CalculationResult{
                        Input:   &amp;input,
                        Result:  rationalNumber,
                        ErrorId: error,
                },
        }, err</span>
}

func buildCalculationsPageObject(cursorPositions CursorPositions, items []HistoryRow) CalculationsPageObject <span class="cov0" title="0">{
        return CalculationsPageObject{
                Self:  cursorPositions.Self,
                First: cursorPositions.First,
                Prev:  cursorPositions.Prev,
                Next:  cursorPositions.Next,
                Last:  cursorPositions.Last,
                Items: items,
        }
}</span>

func (postgresClient PostgresClient) computeCursorPositions(sessionId string, currentCursorOrNil *int64) (CursorPositions, error) <span class="cov0" title="0">{
        calculationIds, err := postgresClient.getAllCalculationIdsInSessionInDescendingOrder(sessionId)

        if err != nil </span><span class="cov0" title="0">{
                return CursorPositions{}, err
        }</span>

        <span class="cov0" title="0">if len(calculationIds) == 0 </span><span class="cov0" title="0">{
                return CursorPositions{
                        First: nil,
                        Prev:  nil,
                        Next:  nil,
                        Last:  nil,
                }, nil
        }</span>

        <span class="cov0" title="0">first := calculationIds[0]

        var idxOfLast int
        if len(calculationIds)%pageMaxNumberOfItems == 0 </span><span class="cov0" title="0">{
                idxOfLast = len(calculationIds) - pageMaxNumberOfItems
        }</span> else<span class="cov0" title="0"> {
                idxOfLast = pageMaxNumberOfItems * (len(calculationIds) / pageMaxNumberOfItems)
        }</span>

        <span class="cov0" title="0">last := calculationIds[idxOfLast]

        idxOfCurrent := 0

        if currentCursorOrNil != nil </span><span class="cov0" title="0">{
                currentCursor := *currentCursorOrNil
                log.Println("computeCursorPositions: Got current cursor", currentCursor)

                for idxOfCurrent &lt; len(calculationIds) &amp;&amp; calculationIds[idxOfCurrent] &gt; currentCursor </span><span class="cov0" title="0">{
                        idxOfCurrent++
                }</span>

                <span class="cov0" title="0">log.Println("computeCursorPositions: Computed idxOfCurrent", idxOfCurrent)

                if idxOfCurrent == len(calculationIds) </span><span class="cov0" title="0">{
                        // request is asking for a list with calculation ids below or equal to the lowest calculation id in the list
                        // The result will always be an empty list

                        log.Printf("Got into special case where idxOfCurrent=%v is out of bounds", idxOfCurrent)

                        result := CursorPositions{
                                Self:  &amp;currentCursor,
                                First: &amp;first,
                                Prev:  &amp;last,
                                Next:  nil,
                                Last:  &amp;last,
                        }
                        return result, nil
                }</span>

                <span class="cov0" title="0">log.Printf("computeCursorPositions: currentCursor: %d, idxOfCurrent: %d", currentCursor, idxOfCurrent)</span>

        }

        <span class="cov0" title="0">idxOfPrev := idxOfCurrent - pageMaxNumberOfItems
        if idxOfPrev &lt; 0 </span><span class="cov0" title="0">{
                idxOfPrev = 0
        }</span>

        <span class="cov0" title="0">idxOfNext := idxOfCurrent + pageMaxNumberOfItems

        if idxOfNext &gt;= len(calculationIds) </span><span class="cov0" title="0">{
                idxOfNext = len(calculationIds) - 1
        }</span>

        <span class="cov0" title="0">self := calculationIds[idxOfCurrent]

        prevResult := &amp;calculationIds[idxOfPrev]
        if self == first </span><span class="cov0" title="0">{
                prevResult = nil
        }</span>

        <span class="cov0" title="0">nextResult := &amp;calculationIds[idxOfNext]
        if self == last </span><span class="cov0" title="0">{
                nextResult = nil
        }</span>

        <span class="cov0" title="0">return CursorPositions{
                Self:  &amp;self,
                First: &amp;first,
                Prev:  prevResult,
                Next:  nextResult,
                Last:  &amp;last,
        }, nil</span>
}

func (postgresClient PostgresClient) getAllCalculationIdsInSessionInDescendingOrder(sessionId string) ([]int64, error) <span class="cov0" title="0">{
        rows, err := postgresClient.conn.Query(context.Background(), "SELECT calculationId FROM history WHERE sessionId=$1 ORDER BY calculationId DESC", sessionId)

        if err != nil </span><span class="cov0" title="0">{
                return []int64{}, err
        }</span>

        <span class="cov0" title="0">result := make([]int64, 0)

        var calculationId int64
        for rows.Next() </span><span class="cov0" title="0">{
                err := rows.Scan(&amp;calculationId)

                if err != nil </span><span class="cov0" title="0">{
                        return []int64{}, err
                }</span>

                <span class="cov0" title="0">result = append(result, calculationId)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func (postgresClient PostgresClient) GetSessionHistoryFirstPage(sessionId string) (CalculationsPageObject, error) <span class="cov0" title="0">{
        cursorPositions, err := postgresClient.computeCursorPositions(sessionId, nil)

        if err != nil </span><span class="cov0" title="0">{
                return CalculationsPageObject{}, errors.New(computeCursorPositionsError)
        }</span>

        <span class="cov0" title="0">if cursorPositions.Self == nil </span><span class="cov0" title="0">{
                // Empty list, send empty list
                return CalculationsPageObject{Items: []HistoryRow{}}, nil
        }</span>
        <span class="cov0" title="0">return postgresClient.GetSessionHistoryFromCursor(sessionId, cursorPositions)</span>
}

func (postgresClient PostgresClient) GetSessionHistory(sessionId string, cursor int64) (CalculationsPageObject, error) <span class="cov0" title="0">{
        cursorPositions, err := postgresClient.computeCursorPositions(sessionId, &amp;cursor)

        if err != nil </span><span class="cov0" title="0">{
                return CalculationsPageObject{}, errors.New(computeCursorPositionsError)
        }</span>

        <span class="cov0" title="0">if cursorPositions.Self == nil </span><span class="cov0" title="0">{
                // Empty list, send empty list
                return CalculationsPageObject{Items: []HistoryRow{}}, nil
        }</span>
        <span class="cov0" title="0">return postgresClient.GetSessionHistoryFromCursor(sessionId, cursorPositions)</span>
}

func (postgresClient PostgresClient) GetSessionHistoryFromCursor(sessionId string, cursorPositions CursorPositions) (CalculationsPageObject, error) <span class="cov0" title="0">{
        log.Printf("Fetching session history for sessionId %s with cursor %d", sessionId, cursorPositions.Self)
        rows, err := postgresClient.conn.Query(context.Background(),
                `SELECT calculationId, input, outputnum, outputdenom, outputestimate, error 
                 FROM HISTORY WHERE sessionId=$1 AND calculationId&lt;=$2 ORDER BY calculationId DESC LIMIT $3`,
                sessionId,
                cursorPositions.Self,
                pageMaxNumberOfItems)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("GetSessionHistory: Could not SELECT. Error: %s", err.Error())
                return CalculationsPageObject{}, errors.New(fetchHistoryErrorId)
        }</span>

        <span class="cov0" title="0">items := make([]HistoryRow, 0, pageMaxNumberOfItems)

        for rows.Next() </span><span class="cov0" title="0">{
                calculationsResult, err := scanHistoryRow(rows)

                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("GetSessionHistory: Could not scan. Error: %s", err.Error())
                        return CalculationsPageObject{}, errors.New(scanRowHistoryError)
                }</span>

                <span class="cov0" title="0">items = append(items, calculationsResult)</span>
        }

        <span class="cov0" title="0">return buildCalculationsPageObject(cursorPositions, items), nil</span>
}

func InitPostgresClient() (PostgresClient, error) <span class="cov0" title="0">{
        databaseUrl := getDatabaseUrl()
        conn, err := pgx.Connect(context.Background(), databaseUrl)
        if err != nil </span><span class="cov0" title="0">{
                return PostgresClient{}, err
        }</span>

        <span class="cov0" title="0">return PostgresClient{conn: conn}, nil</span>
}

func getDatabaseUrl() string <span class="cov0" title="0">{
        username := os.Getenv("POSTGRES_USER")
        password := os.Getenv("POSTGRES_PASSWORD")

        host := os.Getenv("POSTGRES_HOST")
        if host == "" </span><span class="cov0" title="0">{
                host = "localhost"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("postgres://%s:%s@%s:5432/calculator", username, password, host)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "bytes"
        "io"
        "log"
        "log/slog"
        "net/http"
        "os"

        sloggin "github.com/samber/slog-gin"

        "github.com/etboye/calculator/api"
        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
)

type GinServer struct {
}

func (ginServer *GinServer) StartServer(endpoints api.Endpoints) error <span class="cov0" title="0">{
        router := gin.Default()

        setupLogging(router)
        registerEndpoints(router, endpoints)

        return router.Run()
}</span>

func setupLogging(router *gin.Engine) <span class="cov0" title="0">{
        config := sloggin.Config{
                WithRequestBody:    true,
                WithRequestHeader:  true,
                WithResponseBody:   true,
                WithResponseHeader: true,
        }
        logger := slog.New(slog.NewTextHandler(os.Stdout, nil))

        router.Use(sloggin.NewWithConfig(logger, config))
}</span>

func registerEndpoints(router *gin.Engine, endpoints api.Endpoints) <span class="cov0" title="0">{
        router.POST("/sessions/:sessionid/compute", func(c *gin.Context) </span><span class="cov0" title="0">{
                computeRequest := api.ComputeRequest{}

                if unmarshallError := c.ShouldBindBodyWith(&amp;computeRequest, binding.JSON); unmarshallError != nil </span><span class="cov0" title="0">{
                        bodyAsString := getBodyAsString(c.Request.Body)
                        log.Println("Could not marshall request", bodyAsString) // TODO: Test this
                        c.Status(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">sessionId := c.Param("sessionid") // TODO: Test empty
                computeResponse := endpoints.ComputationHandler.Compute(sessionId, computeRequest)
                sendSimpleHttpResponse(c, computeResponse)</span>
        })

        <span class="cov0" title="0">router.GET("/sessions/:sessionid/history", func(c *gin.Context) </span><span class="cov0" title="0">{
                sessionId := c.Param("sessionid") // TODO: Test empty
                cursor := c.Query("cursor")
                response := endpoints.SessionHistoryHandler.GetSessionHistory(sessionId, cursor)
                sendSimpleHttpResponse(c, response)
        }</span>)
}

func getBodyAsString(body io.ReadCloser) string <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        buf.ReadFrom(body)
        return buf.String()
}</span>

func sendSimpleHttpResponse[T any](c *gin.Context, httpResponse api.SimpleHttpResponse[T]) <span class="cov0" title="0">{
        c.JSON(httpResponse.Status, httpResponse.Response)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package util

import "fmt"

type withError[T any] struct {
        t   T
        err error
}

func RecoverFromPanicWithError[T any](f func() (T, error), recoverItem T, recoverError error, recoverMessage string) (T, error) <span class="cov8" title="1">{
        resultWithError := RecoverFromPanic[withError[T]](func() withError[T] </span><span class="cov8" title="1">{
                t, err := f()

                result := withError[T]{t: t, err: err}
                return result
        }</span>, withError[T]{t: recoverItem, err: recoverError}, recoverMessage)

        <span class="cov8" title="1">return resultWithError.t, resultWithError.err</span>
}

func RecoverFromPanic[T any](f func() T, recoverItem T, recoverMessage string) T <span class="cov8" title="1">{
        c := make(chan T)

        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                fmt.Println(recoverMessage, r)
                                c &lt;- recoverItem
                        }</span>
                }()

                <span class="cov8" title="1">c &lt;- f()</span>
        }()

        <span class="cov8" title="1">result := &lt;-c
        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
